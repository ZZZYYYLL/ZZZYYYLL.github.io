<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>路径问题的动态规划解</title>
      <link href="/2022/12/13/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3/"/>
      <url>/2022/12/13/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>主要讲述的是关于路径问题的动态规划解，比如最短步数、不同路径等，都可以通过动态规划求解，本文选择的是较为相似的例子，来自于Leetcode。</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><p><a href="https://leetcode.cn/problems/unique-paths/"><strong>点击跳转原题</strong></a>，题目讲述的是机器人从左上角走到右下角有多少种不同路径，且机器人只能向下或者向右走。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m=3 ，n=7</span><br><span class="line">输出：28</span><br><span class="line"></span><br><span class="line">输入：m=3；，n=2</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>排列组合问题，从左下角走到右下角一共要走m+n-2步，其中包括m-1步向下走，n-1步向右走，可以通过C来运算。</p><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>通过动态规划求解，对于走到(m,n)，要么从(m-1,n)往下走，要么从(m,n-1)往右走。所以<strong>对于走到(m,n)点的路径个数为(m-1,n)与(m,n-1)路径格数之和</strong>，而对于第一行或者第一列上的都只有<strong>一种路径</strong>，列出的表达式如下。<br>$f(0,n)=1\, \, \, \, \, \, \, \, \, \, n\geq 0$</p><script type="math/tex; mode=display">f(m,0)=1\, \, \, \, \, \, \, \, \, \, m\geq 0</script><script type="math/tex; mode=display">f(m,n)=f(m-1,n)+f(m,n-1)\, \, \, \, \, \, \, \, \, \, m\geq 1,n\geq 1</script><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    <span class="comment">//第一列初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一行初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历剩余的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h3><p><a href="https://leetcode.cn/problems/unique-paths-ii/"><strong>点击跳转原题</strong></a>，多了障碍物，和不同路径的思路基本一致，将有障碍物的地方设置为0即可，意思是不可达到。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">输入：obstacleGrid = [[0,1],[0,0]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化第一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="comment">//当第一列有障碍物时，其障碍物后面的行都为0</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="comment">//当第一行有障碍物时，其障碍物后面的列都为0</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历剩余的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">//遇到障碍物时，设置为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                f[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><p><a href="https://leetcode.cn/problems/minimum-path-sum/"><strong>点击跳转原题</strong></a>，和上几题类似</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line"></span><br><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化第一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化第一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        f[<span class="number">0</span>][j] = f[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历剩余的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">//选择两个方向的最小值与当前格的步数相加</span></span><br><span class="line">            f[i][j] = Math.min(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p><a href="https://leetcode.cn/problems/climbing-stairs/"><strong>点击跳转原题</strong></a>，基本没什么变化，就是从二维变到了一维</p><script type="math/tex; mode=display">f(0)=1</script><script type="math/tex; mode=display">f(1)=1</script><script type="math/tex; mode=display">f(n)=f(n-1)+f(n-2)\, \, \, \, \, \, \, \, \, \, n\geq 2</script><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云的基本概念和术语</title>
      <link href="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/"/>
      <url>/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>简单的介绍有关于云的基本概念和专业术语</p></blockquote><h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p>云是一种独特的IT环境，其设计目的是为了远程供给可扩展和可测量的IT资源</p><h2 id="IT资源"><a href="#IT资源" class="headerlink" title="IT资源"></a>IT资源</h2><p>IT资源是指一个与IT相关的物理的或者虚拟的事物，它既可以基于软件的，也可以基于硬件的</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221108181655802.png"></p><p><strong>注意以下两点：</strong></p><ul><li>一个给定云符号边界中画出的T资源并不代表这个云中包含的所有可用IT资源。</li><li>图示中只会显示实际技术的部分细节。</li></ul><h2 id="内部的"><a href="#内部的" class="headerlink" title="内部的"></a>内部的</h2><p>“内部的”是指“在一个不基于云的可控的IT环境内部的”</p><p>要注意的三点：</p><ul><li>一个内部的IT资源可以访问一个基于云的资源，并与之交互</li><li>一个内部的IT资源可以被迁移到云中，从而成为一个基于云的IT资源</li><li>IT资源既可以冗余部署在内部的环境中，也可以在云环境中</li></ul><h2 id="云用户和云提供者"><a href="#云用户和云提供者" class="headerlink" title="云用户和云提供者"></a>云用户和云提供者</h2><p>云用户：使用基于云的IT资源一方</p><p>云提供者：提供基于云的IT资源的一方</p><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>从IT资源的角度来看，可扩展性是指IT资源可以处理增加或减少的使用需求的能力</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>水平扩展——向外或向内扩展</p><p>垂直扩展——向上或向下扩展</p><h3 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h3><p>分配和释放IT资源都属于水平扩展。</p><p>水平分配资源也称<strong>向外扩展</strong>，水平释放资源也称<strong>向内扩展</strong>。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221108182026551.png"></p><h3 id="垂直扩展"><a href="#垂直扩展" class="headerlink" title="垂直扩展"></a>垂直扩展</h3><p>当一个现有IT资源被具有更大或者更小容量的资源所代替，成为垂直扩展。</p><p>被具有更大容量的IT资源代替，称为向上扩展，被具有更小容量的IT资源代替，称为向下扩展。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221108182300132.png"></p><h3 id="水平扩展和垂直扩展的比较"><a href="#水平扩展和垂直扩展的比较" class="headerlink" title="水平扩展和垂直扩展的比较"></a>水平扩展和垂直扩展的比较</h3><table><thead><tr><th align="center">水平扩展</th><th align="center">垂直扩展</th></tr></thead><tbody><tr><td align="center">更便宜</td><td align="center">更昂贵</td></tr><tr><td align="center">IT资源立即可用</td><td align="center">IT资源通常立即可用</td></tr><tr><td align="center">资源复制和自动扩展</td><td align="center">通常需要额外设置</td></tr><tr><td align="center">不受硬件容量限制</td><td align="center">受限于硬件最大容量</td></tr></tbody></table><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><h3 id="云提供者"><a href="#云提供者" class="headerlink" title="云提供者"></a>云提供者</h3><p>云提供者是提供基于云的IT资源的组织机构。</p><p><strong>任务：</strong></p><ul><li>依据每个SLA（Service-Level Agreement，服务等级协议）保证，负责向云用户保证云服务可用</li><li>必要的管理和行政职责，保证整个云基础设施的持续运行</li></ul><h3 id="云用户"><a href="#云用户" class="headerlink" title="云用户"></a>云用户</h3><p>云用户是组织机构或者人，与云提供者签订正式的合同来使用云提供者提供的IT资源。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221108184141405.png"></p><h3 id="云服务拥有者"><a href="#云服务拥有者" class="headerlink" title="云服务拥有者"></a>云服务拥有者</h3><p>云服务拥有者是在法律上拥有云服务的个人或者组织</p><h3 id="云资源管理者"><a href="#云资源管理者" class="headerlink" title="云资源管理者"></a>云资源管理者</h3><p>云资源管理者是负责管理基于云的IT资源（包括云服务）的人或组织。可以是云的云用户、云提供者或者第三方组织。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221108184604343.png"></p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221108184619578.png"></p><h3 id="云审计者"><a href="#云审计者" class="headerlink" title="云审计者"></a>云审计者</h3><p>对云环境进行独立评估的第三方（通常是通过认证的），承担的是云审计者的角色。这个角色的典型责任包括安全控制评估、隐私影响以及性能评估。云审计者这一角色的主要目的是提供对云环境的公平评价（和可能的背书），帮助加强云用户和云提供者之间的信任关系。</p><h3 id="云代理"><a href="#云代理" class="headerlink" title="云代理"></a>云代理</h3><p>这个角色要承担管理和协商云用户和云提供者之间云服务使用的责任。云代理提供的仲裁服务包括服务调解、聚合和仲裁。</p><h3 id="云运营商"><a href="#云运营商" class="headerlink" title="云运营商"></a>云运营商</h3><p>负责提供云用户和云提供者之间的线路级连接。这个角色通常由网络和电信提供商担任。</p><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><h3 id="组织边界"><a href="#组织边界" class="headerlink" title="组织边界"></a>组织边界</h3><p>组织边界（organizational boundary）是一个物理范围，包括由一家组织拥有和管理的IT资源的集合。组织边界不表示组织实际的边界，只是该组织的T资产和IT资源。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221108185004839.png"></p><h3 id="信任边界"><a href="#信任边界" class="headerlink" title="信任边界"></a>信任边界</h3><p>信任边界（trust boundary）是一个逻辑范围，通常会跨越物理边界，表明IT资源受信任的程度。在分析云环境的时候，信任边界最常与作为云用户的组织发出的信任关联到一起。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221108185103341.png"></p><h2 id="云特性"><a href="#云特性" class="headerlink" title="云特性"></a>云特性</h2><p>比较常见的六种特性：按需使用、随处访问、多租户（和资源池）、弹性、可测量的使用、可恢复性</p><h3 id="按需使用"><a href="#按需使用" class="headerlink" title="按需使用"></a>按需使用</h3><p>云用户可以单边访问基于云的IT资源，给予云用户自助提供IT资源的自由。一旦配置好了，对自助提供的IT资源的访问可以自动化，不再需要云用户或是云提供者的介入。这就是<strong>按需使用(on-demand usage)的环境</strong>，也称为“按需自助服务使用”。</p><h3 id="泛在接入"><a href="#泛在接入" class="headerlink" title="泛在接入"></a>泛在接入</h3><p>泛在接入(ubiquitous access)是一个云服务可以被广泛访问的能力。</p><h3 id="多租户（和资源池）"><a href="#多租户（和资源池）" class="headerlink" title="多租户（和资源池）"></a>多租户（和资源池）</h3><p>一个软件程序的实例能够服务不同的用户（租户)，租户之间是互相隔离的，使得软件程序具有这种能力的特性称为多租户（multitenancy)。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221108185722488.png"></p><h3 id="弹性"><a href="#弹性" class="headerlink" title="弹性"></a>弹性</h3><p>弹性(elasticity)是一种能力，云根据运行时条件或云用户或云提供者事先确定的要求，自动透明地扩展IT资源。</p><h3 id="可测量的使用"><a href="#可测量的使用" class="headerlink" title="可测量的使用"></a>可测量的使用</h3><p>可测量的使用(measured usage)特性表示的是云平台记录对IT资源使用情况的能力，这些IT资源主要是被云用户使用的。</p><h3 id="可恢复性"><a href="#可恢复性" class="headerlink" title="可恢复性"></a>可恢复性</h3><p>可恢复计算(resilient computing)是一种故障转移(failover)的形式，它在多个物理位置分放IT资源的冗余实现。</p><h2 id="云交付模型"><a href="#云交付模型" class="headerlink" title="云交付模型"></a>云交付模型</h2><h3 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h3><p>IaaS交付模型是一种自我包含的IT环境，由以基础设施为中心的IT资源组成，可以通过基于云服务的接口和工具访问和管理这些资源。</p><p>IaaS环境一般要允许云用户对其资源配置和使用进行更高层次的控制。IaaS提供的IT资源通常是未配置好的，管理的责任直接落在云用户身上。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221109183115790.png"></p><h3 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h3><p>PaaS交付模型是预先定义好的“就绪可用”的环境，一般由已经部署好和配置好的IT资源组成。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221109183231577.png"></p><h3 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h3><p>SaaS通常是把软件程序定位成共享的云服务，作为“产品”或通用的工具进行提供。SaaS交付模型一般是使一个可重用云服务对大多数云用户可用（通常是商用）。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221109183251778.png"></p><h3 id="云交互模型的比较"><a href="#云交互模型的比较" class="headerlink" title="云交互模型的比较"></a>云交互模型的比较</h3><table><thead><tr><th align="center">云交互模型</th><th align="center">赋予云用户的典型控制等级</th><th align="center">云用户可用的典型功能</th></tr></thead><tbody><tr><td align="center">SaaS</td><td align="center">使用和与使用相关的配置</td><td align="center">前端用户接口访问</td></tr><tr><td align="center">PaaS</td><td align="center">有限的管理</td><td align="center">对与云用户使用平台相关的T资源的中等级别的管理控制</td></tr><tr><td align="center">IaaS</td><td align="center">完全的管理</td><td align="center">对虚拟化的基础设施相关的IT资源以及可能的底层物理IT资源的完全访问</td></tr></tbody></table><h2 id="云部署模型"><a href="#云部署模型" class="headerlink" title="云部署模型"></a>云部署模型</h2><p>常见的四种云部署模型：<strong>公有云，社区云，私有云，混合云</strong></p><h3 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h3><p><strong>公有云</strong>是由第三方云提供者拥有的可公共访问的云环境。公有云里的IT资源通常是按照事先描述好的云交付模型提供的，而且一般是需要付费才能提供给云用户的，或者是通过其他途径商业化的（例如广告）。</p><h3 id="社区云"><a href="#社区云" class="headerlink" title="社区云"></a>社区云</h3><p><strong>社区云</strong>类似于公有云，只是它的访问被限制为特定的云用户社区。社区云可以是社区成员或提供具有访问限制的公有云的第三方云提供者共同拥有的。社区的云用户成员通常会共同承担定义和发展社区云的责任。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221109183943933.png"></p><h3 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h3><p>私有云是由一家组织单独拥有的。私有云使得组织把云计算技术当做一种手段，可以集中访问不同部分、位置或部门的IT资源。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221109184013344.png"></p><h3 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h3><p>混合云是由两个或者更多不同云部署模型组成的云环境。例如，云用户可能会选择把处理敏感数据的云服务部署到私有云上，而将其他不那么敏感的云服务部署到公有云上。这种组合就得到了混合署模型。</p><p><img src="/2022/11/08/%E4%BA%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20221109184037618.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发程序设计学习笔记4</title>
      <link href="/2022/09/06/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/"/>
      <url>/2022/09/06/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>介绍了线程池有关的基本知识</p></blockquote><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="/2022/09/06/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/20210518151544449.png"></p><ol><li>提交任务后判断核心线程池是否已满，即判断已创建线程数是否小于corePoolSize。没满，创建新线程执行任务；满了，进入下个流程。</li><li>接着判断工作队列是否已满。没满，将任务添加到队列，等待实行；满了，进入下个流程。</li><li>最后判断线程池是否已满，即判断已创建线程数是否小于maximumPoolSize。没满，创建新线程执行任务；满了，交给饱和策略处理这个任务</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li><li>提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行；</li><li>方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率；</li><li>更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。</li></ol><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span></span><br></pre></td></tr></table></figure><ul><li><code>newFixedThreadPool(int nThreads)</code>该方法返回一个<strong>固定线程数量</strong>的线程池。</li><li><code>newSingleThreadExecutor()</code>该方法返回一个<strong>只有一个线程</strong>的线程池。</li><li><code>newCachedThreadPool()</code>该方法返回一个<strong>可根据实际情况调整线程数量</strong>的线程池。</li><li><code>newSingleThreadScheduledExecutor()</code>该方法返回一个ScheduledExecutorService对象，线程池大小为1。此类对象在ExecutorService的基础上拓展了在给定时间实行某项任务的功能</li><li><code>newScheduledThreadPool(int corePoolSize)</code>与<code>newSingleThreadScheduledExecutor()</code>类似，但是可以指定线程池中的线程数量。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>上述讲到的方法全是ThreadPoolExecutor类的封装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>corePoolSize</code>：线程池中的线程数量</li><li><code>maximumPoolSize</code>：线程池中的最大线程数量</li><li><code>keepAliveTime</code>：当线程池线程数量超过corePoolSize时，多余的空闲线程的存活时间</li><li><code>unit</code>：keepAliveTime的单位</li><li><code>workQueue</code>：任务队列，被提交但未被执行的任务</li><li><code>threadFactory</code>：线程工厂，用于创建线程，默认即可</li><li><code>handler</code>：拒绝策略。当任务太多来不及处理，如何拒绝任务</li></ul><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>一共有四种任务队列，分别为，ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue，PriorityBlockingQueue。下面一一介绍。</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>基于数组的有界队列，队列按FIFIO原则对元素进行排序。当使用有界的任务队列时，若有新的任务需要执行，如果线程池的实际线程数小于corePoolSize,则会优先创建新的线程，若大于corePoolSize,则会将新任务加入等待队列。若等待队列已满，无法加入，则在总线程数不大于maximumPoolSize的前提下，创建新的进程执行任务。若大于maximumPoolSize，则执行拒绝策略。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>基于链表的无界阻塞队列。与ArrayBlockingQueue一样采用FIFO原则对元素进行排序。除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况。当有新的任务到来，系统的线程数小于corePoolSize时，线程池会生成新的线程执行任务，但当系统的线程数达到corePoolSize后，就不会继续增加了。若后续仍有新的任务加入，而又没有空闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。基于链表的队列吞吐量通常要高于基于数组的队列。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>同步的阻塞队列。其中每个插入操作必须等待另一个线程的对应移除操作，等待过程一直处于阻塞状态，同理，每一个移除操作必须等到另一个线程的对应插入操作。如果使用SynchronousQueue，则提交的任务不会被真实的保存，而总是将新任务交给线程执行。使用SynchronousQueue队列，通常要设置很大的maximumPoolSize，否则很容易执行拒绝策略。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>基于优先级的无界阻塞队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。确保性能的同时，也有很好的质量保证。</p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><ul><li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作</li><li>CallerRunsPolicy策略：只要线程池为关闭，该策略直接在调用者线程中，运行当前被丢弃的任务</li><li>DiscardOldestPolicy策略：该策略会丢弃即将被执行的一个任务，并尝试再次提交当前任务</li><li>DiscardPolicy策略：该策略丢弃无法处理的任务，不予任何处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发程序设计学习笔记3</title>
      <link href="/2022/09/05/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
      <url>/2022/09/05/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>主要介绍了重入锁，重入锁的”好搭档”Condition，信号量，一些线程控制工具和限流的概念。</p></blockquote><h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li><code>lock()</code>，获得锁，如果锁被占用则等待</li><li><code>lockInterruptibly()</code>，获得锁，但优先相应中断</li><li><code>tryLock()</code>，尝试获得锁，若成功，返回true；否则false。不等待，立即返回</li><li><code>tryLock(long time, TimeUnit unit)</code>，在给定的时间内尝试获得锁</li><li><code>unlcok()</code>，释放锁</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReenterLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="type">ReenterLock</span> <span class="variable">reenterLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenterLock</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(reenterLock);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(reenterLock);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与关键字synchronized相比，重入锁有着明显的操作过程，必须手动加锁和释放锁，<strong>灵活性更高</strong>。重入锁还体现了<strong>中断响应</strong>、<strong>锁申请限时等待</strong>、<strong>公平锁</strong>。</p><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><p>对锁的请求，使用<code>lockInterruptibly()</code>方法，这是一个对中断进行相应的锁申请动作，即在锁申请的过程中，可以相应中断。</p><h3 id="锁申请限时等待"><a href="#锁申请限时等待" class="headerlink" title="锁申请限时等待"></a>锁申请限时等待</h3><p><code>tryLock()</code>方法接收两个参数，一个表示等待时长，一个表示计时单位。如<code>lock.tryLock(5,TimeUnit.SECONDS)</code>，若超过等待时长，返回false；否则为true。同样也可以不带任何参数，申请锁成功则<strong>立即返回</strong>true；否则<strong>立即返回</strong>false。</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>在声明重入锁的时候，将锁声明为公平锁，（默认值为false），即：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReenterLock</span> <span class="variable">reenterLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenterLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fairLock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getId() + <span class="string">&quot;:get lock&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                fairLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FairLock</span> <span class="variable">fairLock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FairLock</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(fairLock1, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(fairLock1, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>公平锁运行结果</strong>：</p><p><img src="/2022/09/05/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220906150004188.png"></p><p><strong>非公平锁运行结果</strong>：</p><p><img src="/2022/09/05/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220906150114841.png"></p><p><img src="/2022/09/05/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220906150203887.png"></p><p>可以明显的区分，<strong>公平锁</strong>是使两个线程交替获得锁；<strong>非公平锁</strong>则是根据系统的调度，一个线程更倾向于再次获取已经持有的锁。<strong>公平锁</strong>要求系统维护一个有序的队列，成本高，性能低下；<strong>非公平锁</strong>分配的方式是高效的，但是无公平可言</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><blockquote><p>重入锁的好搭档</p></blockquote><h3 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li><code>await()</code>使当前进程等待，并释放当前锁。</li><li><code>awaitUninterruptibly</code>与<code>await()</code>一样，只不过在等待过程中不会响应中断。</li><li><code>siginal()</code>唤醒一个等待线程，<code>signalALL()</code>唤醒所有等待线程。</li></ul><h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><h3 id="主要方法-2"><a href="#主要方法-2" class="headerlink" title="主要方法"></a>主要方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数表示信号量的准入量，第二个参数表示是否公平</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure><ul><li><code>acquire()</code>尝试获得一个准入的许可。若无法获得则等待，直到有线程释放许可或当前线程被中断。</li><li><code>acquireUninterruptibly()</code>与<code>acquire()</code>一样，但不响应中断。</li><li><code>tryAcquire()</code>尝试获得一个准入许可，成功返回true；否则false。也可以带参数。与<code>tryLock()</code>类似。</li><li><code>release()</code>释放一个准入的许可</li></ul><h2 id="线程控制工具类"><a href="#线程控制工具类" class="headerlink" title="线程控制工具类"></a>线程控制工具类</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>实现线程之间计数等待。</p><p><img src="/2022/09/05/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220906155319147.png"></p><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>除了实现线程间的计数等待，改计数器还可以循环使用。</p><p><img src="/2022/09/05/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220906155427896.png"></p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p><strong>为什么要限流？</strong></p><p>任何应用和模块组件都有一定的访问速率上限，如果请求速率突破了这个上限，不但多余的请求无法处理，甚至会压垮系统使所有的请求均无法有效处理。因此，对请求进行限流是非常必要的。一般的限流算法包括<strong>漏桶算法</strong>和<strong>令牌桶算法</strong></p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p><img src="/2022/09/05/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220906190135791.png"></p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>利用一个缓存区，当有请求进入系统时，无论请求的速率如何，都先在缓存区内保存，然后以固定的流速流出缓存区进行处理。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>漏桶算法的特点是无论外部请求压力如何，漏桶算法总是以固定的流速处理数据。漏桶的容积和流出速率是该算法的两个重要参数。</p><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p><img src="/2022/09/05/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220906191335365.png"></p><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>令牌桶算法是一种反向的漏桶算法。在令牌桶算法中，桶中存放的不再是请求，而是令牌。处理程序只有拿到令牌后，才能对请求进行处理。如果没有令牌，那么处理程序要么丢弃请求，要么等待可用的令牌。为了限制流速，该算法在每个单位时间产生一定量的令牌存入桶中。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发程序设计学习笔记2</title>
      <link href="/2022/09/04/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>/2022/09/04/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>主要介绍线程的各种状态，volatile关键字的详细解读，以及守护线程的概念和作用</p></blockquote><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">NEW,</span><br><span class="line">RUNNABLE,</span><br><span class="line">BLOCKED,</span><br><span class="line">WAITING,</span><br><span class="line">TIME_WAITING,</span><br><span class="line">TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>NEW</strong></p><p>表示刚刚创建好的线程，还没有开始执行</p></li><li><p><strong>RUNNABLE</strong></p><p>线程一切所需的资源都准备好了，执行状态</p></li><li><p><strong>BLOCK</strong></p><p>阻塞状态，如遇到synchronized同步块</p></li><li><p><strong>WAITING</strong></p><p>无时间限制的等待，比如通过wait()方法的线程来等待notify()方法，join()方法等待的线程会等待目标线程的终止</p></li><li><p><strong>TIMED_WAITING</strong></p><p>有时间限制的等待</p></li><li><p><strong>TERMINATED</strong></p><p>结束状态</p></li></ul><h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>​Java语言提供一中稍弱的同步机制，即volatile变量，用来确保变量的更新通知到其他线程。当声明了volatile变量，编译器<strong>不会将该变量上的操作与其他内存操作一起重排序</strong>。volatile变量<strong>不会被缓存在寄存器或者对其他处理器不可见的地方</strong>（确保了可见性），因此在读取volatile类型的变量时总会返回最新写入的值。</p><p><img src="/2022/09/04/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/731716-20160708224602686-2141387366-16622746856931.png"></p><p>​当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p><p>​<strong>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</strong></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>保证此变量对所有的线程的可见性</li><li>禁止指令重排序优化</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoVisibility</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready);</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​当ready变量没有加volatile关键字的时候，读线程**”看不到”** ready发生了变化，会陷入死循环，打印不出number的值。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>volatile只能确保数据的可见性和有序性，但却不能确保数据的原子性，尤其是一些复合操作，例如：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TaskPlus</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TaskPlus</span>());</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="/2022/09/04/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220904152651301.png"></p><h2 id="守护线程（DAEMON"><a href="#守护线程（DAEMON" class="headerlink" title="守护线程（DAEMON)"></a>守护线程（DAEMON)</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonDemon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DaemonT</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I am alive&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaemonT</span>();</span><br><span class="line">            thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><p><img src="/2022/09/04/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220904153427646.png"></p><p>​当thread被设置为守护线程，main线程在休眠2秒后推出，整个程序也随之结束。若thread没有被设置为守护线程，当main线程退出后，thread线程还在不断打印。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>​设置守护线程必须在线程开始之前，否则会出现下面的异常</p><p><img src="/2022/09/04/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220904153952247.png"></p><p>​虽然程序依旧可以运行，但是守护线程设置未成功，程序停不下来。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发程序设计学习笔记1</title>
      <link href="/2022/09/04/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
      <url>/2022/09/04/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>主要介绍一些基础知识和JMM的特性</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ul><li><p><strong>同步方法</strong>调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</p><p><img src="/2022/09/04/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/1680783-20190521124754180-1985908967.png"></p></li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul><li><p><strong>异步方法</strong>调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作</p><p><img src="/2022/09/04/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/1680783-20190521125411515-1327485285.png"></p></li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li>偏重于多个任务交替进行，在使用者看来，多个任务是“同时进行的”</li></ul><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><ul><li>真正意义上的同时进行</li></ul><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><ul><li><strong>临界区</strong>指的是一个访问公用资源的程序片段，这些公共资源又无法同时被多个线程访问的特性，当有线程进入临界区段是，其他线程或者进程必须等待</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><strong>死锁</strong>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</li><li><strong>死锁产生</strong>的四个必要条件<ol><li>互斥条件</li><li>请求与保持条件</li><li>不可剥夺条件</li><li>循环等待条件</li></ol></li></ul><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><ul><li><strong>饥饿</strong>是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行</li></ul><h2 id="Java的内存模型（JMM）"><a href="#Java的内存模型（JMM）" class="headerlink" title="Java的内存模型（JMM）"></a>Java的内存模型（JMM）</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul><li><strong>原子性是指一个操作是不可中断的。</strong>即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。</li></ul><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul><li><strong>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。</strong>也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。</li></ul><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><ul><li>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法</title>
      <link href="/2022/07/28/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/07/28/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串常见操作"><a href="#字符串常见操作" class="headerlink" title="字符串常见操作"></a>字符串常见操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">&quot;hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">字符串转化</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message.title()) <span class="comment"># 首字母大写 &quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message.upper()) <span class="comment"># 转大写 &quot;HELLO WORLD&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message.lower()) <span class="comment"># 转小写 &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">字符串拼接</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">str1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1 + str2) <span class="comment"># &quot;helloworld&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1 * <span class="number">2</span>) <span class="comment"># &quot;hellohello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>.join(str1)) <span class="comment"># &quot;h-e-l-l-o&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">字符串统计</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(str1)) <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">0</span>]) <span class="comment"># &quot;h&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1[-<span class="number">1</span>]) <span class="comment"># &quot;o&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">字符串切片、提取</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">str1 = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">0</span>:<span class="number">4</span>]) <span class="comment"># 下标0到3 &quot;abcd&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">0</span>:<span class="number">4</span>:<span class="number">2</span>]) <span class="comment"># 下标0到3 步长2 &quot;ad&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">4</span>:]) <span class="comment"># 下标4到结束 &quot;fg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[:]) <span class="comment"># 全部 &quot;abdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>]) <span class="comment"># 反向 &quot;gfedba&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">字符串切割</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">s = <span class="string">&quot;this is my first python note&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&quot; &quot;</span>)) <span class="comment"># [&#x27;this&#x27;, &#x27;is&#x27;, &#x27;my&#x27;, &#x27;first&#x27;, &#x27;python&#x27;, &#x27;note&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&quot; &quot;</span>, <span class="number">2</span>)) <span class="comment"># [&#x27;this&#x27;, &#x27;is&#x27;, &#x27;my first python note&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">字符串删除</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">test = <span class="string">&quot; test python &quot;</span></span><br><span class="line"><span class="built_in">print</span>(test.lstrip()) <span class="comment"># 删除首空格 &quot;test python &quot;</span></span><br><span class="line"><span class="built_in">print</span>(test.rstrip()) <span class="comment"># 删除尾空格 &quot; test python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(test.strip()) <span class="comment"># 删除首尾空格 &quot;test python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">字符串查找</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">s = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;b&#x27;</span>)) <span class="comment"># 找到返回下标 1</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;k&#x27;</span>)) <span class="comment"># 没找到返回 -1</span></span><br></pre></td></tr></table></figure><h2 id="列表常见操作"><a href="#列表常见操作" class="headerlink" title="列表常见操作"></a>列表常见操作</h2><h3 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h3><ul><li>通过下标访问</li></ul><h3 id="修改列表元素"><a href="#修改列表元素" class="headerlink" title="修改列表元素"></a>修改列表元素</h3><ul><li>通过下标修改</li></ul><h3 id="添加列表元素"><a href="#添加列表元素" class="headerlink" title="添加列表元素"></a>添加列表元素</h3><ul><li><p><code>append()</code>，添加至末尾</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">motorcycles = [] </span><br><span class="line">motorcycles.append(<span class="string">&#x27;honda&#x27;</span>) </span><br><span class="line">motorcycles.append(<span class="string">&#x27;yamaha&#x27;</span>) </span><br><span class="line">motorcycles.append(<span class="string">&#x27;suzuki&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(motorcycles) <span class="comment"># [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>insert()</code>，在任意位置添加</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>] </span><br><span class="line">motorcycles.insert(<span class="number">0</span>, <span class="string">&#x27;ducati&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(motorcycles) <span class="comment"># [&#x27;ducati&#x27;, &#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h3><ul><li><p><code>del()</code>，删除对应位置的元素</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>] </span><br><span class="line"><span class="keyword">del</span> motorcycles[<span class="number">0</span>] </span><br><span class="line"><span class="built_in">print</span>(motorcycles) <span class="comment"># [&#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>pop()</code>，既删除，也返回对应值，默认弹出末尾元素，带参可以弹出任意元素</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>] </span><br><span class="line">popped_motorcycle = motorcycles.pop()</span><br><span class="line"><span class="built_in">print</span>(popped_motorcycle) <span class="comment"># &#x27;suzuki&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>remove()</code>，参数为列表里面的值，若不存在会报错</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>, <span class="string">&#x27;ducati&#x27;</span>] </span><br><span class="line">motorcycles.remove(<span class="string">&#x27;ducati&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(motorcycles) <span class="comment"># [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h3><ul><li><p><code>sort()</code>，永久排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>] </span><br><span class="line">cars.sort()</span><br><span class="line"><span class="built_in">print</span>(cars) <span class="comment"># [&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">cars.sort(reverse=True) </span></span><br><span class="line"><span class="string">print(cars) # [&#x27;toyota&#x27;, &#x27;subaru&#x27;, &#x27;bmw&#x27;, &#x27;audi&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>sorted(),临时排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>] </span><br><span class="line">sortedCars = <span class="built_in">sorted</span>(cars)</span><br><span class="line"><span class="built_in">print</span>(sortedCars) <span class="comment"># [&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li>由一个个键-值对构成（K-V)，相当于哈希表</li></ul><h3 id="判断是否存在某个key值"><a href="#判断是否存在某个key值" class="headerlink" title="判断是否存在某个key值"></a>判断是否存在某个key值</h3><ul><li><p><code>__contain__</code>，返回一个bool类型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alien = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">800</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(alien.__contains__(<span class="string">&#x27;yes&#x27;</span>)) <span class="comment"># 返回False</span></span><br><span class="line"><span class="built_in">print</span>(alien.__contains__(<span class="string">&#x27;color&#x27;</span>)) <span class="comment"># 返回True</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
